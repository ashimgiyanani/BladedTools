% Script to plot the wind file characteristics generated by Matlab,
%Optional file header info (to give more details about the function than in the H1 line)
%Optional file header info (to give more details about the function than in the H1 line)
%Optional file header info (to give more details about the function than in the H1 line)
%
% Outputs:
%    output1 - Description
%    output2 - Description
%
% Other m-files required: none
% Subfunctions: FnTurbLengthScale,
% MAT-files required: none
%
% See also: cpsd, specest, pwelch, fminsearch  OTHER_FUNCTION_NAME2

% Author: Ashim Giyanani, Ph.D. candidate, wind energy
% Wind energy institute. Delft University of Technology
% email address: ashimgiyanani@yahoo.com
% Website: n/a
% May 2018; Last revision: 09-05-2018

%------------- BEGIN CODE --------------

% Steps followed in the script
% Initialisation
% load the input wind file
% input Spectrum processing variables
% Calculate the IEC spectrum
% Calculate spectrum, coherence and general statistics from the simulated/measured wind file
% Calculate the length scale, decay parameter and other important parameters through optimisation


clear; clc; close all
tic
%% initialisations
NormalizeSpectrum = 0;                                                         % normalize the spectrum, yes - 1, no - 0
PlotFig = 0;                                                                   % plot all figures, yes -1, no -0
funSpec = 'cpsd';                                                              % spectrum function - 'cpsd' / 'specest' / 'pwelch'
km.spec.Spectrum = 'onesided';                                                 % Spectrum type 'oneside' 'twosided' 'centered'
Analyse = 'plane';                                                             % 'point' or 'plane' or 'domain'
verifyScales = 1;                                                              % verify the length scale, yes-1, no-0
Validation = 1;                                                                % validation of the spectrum, yes-1, no-0
isolatedEstimation = 1;                                                        % estimation of length scale and decay in isolation, yes-1, no-0
TaylorMicroscale = 1;                                                          % esimation of taylor microscale
nIter = 10^5;
nEval = 5*10^5;
Tol = 10^-6;
Threshold_f = 1;
%% load the wind file generated by Bladed
addpath('c:\Users\ashim.giyanani\OneDrive - Windwise GmbH\Windwise\PostProcessing\');
addpath('c:\Users\ashim.giyanani\OneDrive - Windwise GmbH\Windwise\Matlab\src\')
filename = 'c:\\Users\\ashim.giyanani\\OneDrive - Windwise GmbH\\Windwise\\TurbSim\\IECKAI_NTM_125x125_150_noScaling';
[u,v,w,x,y,z,U,t, Nx, Ny, Nz, delta_x, delta_y, delta_z, Ug, vg, wg]=readbladed(filename);
ug = Ug - U;

%% Post-processing of the data
km.ref_u = ug(:,floor(Ny/2)+1,floor(Ny/2)+1);  % reference point, hub center u component
km.ref_v = vg(:,floor(Ny/2)+1,floor(Ny/2)+1);  % reference point, v component
km.ref_w = wg(:,floor(Ny/2)+1,floor(Ny/2)+1);  % reference point, w component

% Measure the spectral densities, coherence and the decay factor
km.spec.win = 2.^12;                                                           % spectral window length
km.spec.noverlap = km.spec.win*3/4;                                            % no. of overlapping points
km.spec.Nfft = 2^(nextpow2(length(km.ref_u)));                                 % total no. of fft points
km.spec.dt = nanmean(diff(t));                                                 % time step [s]
km.spec.Fs = 1/km.spec.dt;                                                     % sampling frequency [Hz]
km.spec.T = t(end)+km.spec.dt;                                                 % total time [s], changes every loop
km.spec.t = (0:km.spec.dt:km.spec.T)';                                         % time vector [s]
km.spec.N = length(ug);                                                         % no. of data points, changes every loop
km.spec.k = fix((km.spec.N-km.spec.noverlap)/(km.spec.win-km.spec.noverlap));  % no. of windows
km.spec.df = 1/km.spec.T;                                                      % frequency step
km.spec.f = (0:km.spec.N-1)'*km.spec.df;                                       % frequency vector
km.spec.kw = 2*pi*km.spec.f/nanmean(km.ref_u);                                 % wavenumber vector
W=fft(hamming(km.spec.win));                                                   % fft of the window
WW=W.*conj(W);                                                                 % weighting
KMU=sum(WW)*km.spec.k*(1/km.spec.win)*(km.spec.Fs);                            % scaling factor

% Spectra of u,v and w components
[Suu_temp, fuu] = cpsd(km.ref_u, km.ref_u, km.spec.win, km.spec.noverlap, km.spec.Nfft, km.spec.Fs, km.spec.Spectrum);
[Svv_temp, fvv] = cpsd(km.ref_v, km.ref_v, km.spec.win, km.spec.noverlap, km.spec.Nfft, km.spec.Fs, km.spec.Spectrum);
[Sww_temp, fww] = cpsd(km.ref_w, km.ref_w, km.spec.win, km.spec.noverlap, km.spec.Nfft, km.spec.Fs, km.spec.Spectrum);

if strmatch(Analyse, 'point')
    % General statistics
    km.grd.std_u = nanstd(km.ref_u);
    km.grd.var_u = var(km.ref_u);
    km.grd.cov_u = cov(km.ref_u);                                    % covariance
    [xC, xlags] = xcorr(km.ref_u, 'coeff');
    [km.grd.Rij,imax] = max(xC);
    km.grd.Tdelay = xlags(imax)*km.spec.dt;

    % Calculate the spectrum  and Coherence using the IEC formulation
    delta_x = km.spec.dt*U; % distance parameter
    km.spec.lambda1 = 42; % turbulence scale parameter (for H >= 60m)
    km.spec.Lk1 = 8.1*km.spec.lambda1; % isotropic integral scale parameter 8.1*L1 - u,2.7*L1 - v, 0.66*L1 - w component
    km.spec.Suu = (km.grd.std_u.^2).*(4.*km.spec.Lk1./U)./((1+6.*km.spec.f.*km.spec.Lk1./U).^(5/3)); % autopower PSD
    km.spec.Coh = exp(-12.*sqrt((km.spec.f.*delta_x./U).^2 + (0.12.*delta_x/km.spec.Lk1).^2));

    % Calculate the spectra using cpsd
    if ~isempty(strmatch('cpsd',funSpec))
        [Sii_temp, fii] = cpsd(km.ref_u, km.ref_u, km.spec.win, km.spec.noverlap, km.spec.Nfft, km.spec.Fs, km.spec.Spectrum);
    % Calculate the spectra using specest
    elseif ~isempty(strmatch('specest',funSpec)) % specest outputs onesided spectrum only
        [Sii_temp, fii] = specest(U+km.ref_u, km.spec.win, km.spec.Fs, km.spec.noverlap); %
    % Compute the signal spectrum using pwelch
    elseif ~isempty(strmatch('pwelch',funSpec))
        [Sii_temp, fii] = pwelch(km.ref_u, km.spec.win, km.spec.noverlap, km.spec.Nfft, km.spec.Fs, km.spec.Spectrum); %
        Theta_ii = angle(Sii_temp);         % in radians
    end

    % Length scale from least square fits
    km.spec.var_u = sum(Sii_temp)/km.spec.T;
    f = km.spec.f;
    Specfn = @(L,f) (km.spec.var_u.*(4.*L./U)./((1+6.*f.*L./U).^(5/3)));
    L0 = 40;
    opts= optimset('Display','off', 'MaxFunEvals', nEval, 'MaxIter', nIter, 'TolFun', 10e-15, 'TolX', 10e-15);
    ls_L = lsqcurvefit(Specfn, L0, f, km.spec.Suu, 0, 600);

    % Normalizing the spectrum
    if NormalizeSpectrum == 1
      W=fft(hamming(km.spec.win));                                                 % fft of the window
      WW=W.*conj(W);                                                            % weighting
      KMU=sum(WW)*km.spec.k*(1/km.spec.win)*(km.spec.Fs);                    % scaling factor
      Sii_temp = Sii_temp/KMU;
    end % normalize

    % Transfer the power in the spectrum to one side, something wrong with twosided
    if ~isempty(strmatch('centered', km.spec.Spectrum))
       km.Sii = Sii_temp;
       km.Sii(1:km.spec.Nfft/2-1) = [];
       km.Sii(2:end,1) = 2.*km.Sii(2:km.spec.Nfft/2+1);
       km.fii = (0:(km.spec.Nfft/2))'/(km.spec.Nfft/2).*km.spec.Fs/2
    elseif ~isempty(strmatch('twosided', km.spec.Spectrum))
      km.Sii = Sii_temp(1:km.spec.Nfft/2+1);
      km.Sii(2:end,1) = 2.*Sii_temp(2:km.spec.Nfft/2+1);
      km.fii = (0:(km.spec.Nfft/2))'/(km.spec.Nfft/2).*km.spec.Fs/2
    else
      km.Sii = Sii_temp;
      km.fii = fii;
    end % spectrum

    % Turbulent length scale from the simulation
    [xL, xT, cor_a] = FnTurbLengthScale(km.ref_u, km.spec.dt, U, 'excludeDecay');
    % Compute the turbulence intensity in percent
    Iu = (km.grd.std_u./U)*100;

    % Length scale from fminsearch, works with onesided and centered
    SpecFn = @(L) sum(((km.Sii) - (km.spec.var_u.*(4.*L./U)./((1+6.*km.fii.*L./U).^(5/3)))).^2);
    opts = optimset('MaxFunEvals',nEval, 'MaxIter',nIter,'TolFun', Tol, 'TolX', Tol, 'Display', 'off');
    L0 = 40;
    [hat_L,~,~] =fminsearch(SpecFn, L0, opts);
    fmin_L =  hat_L*2;

    % Fitting the decay coefficient to the measurements
    if (verifyScales == 1)
        deltax = km.spec.dt*U;  % time*wind speed
        a0 = 12;  % decay parameter
        Lx0 = 8.1*xL;      % Kaimal spectrum length scale
        x0 = [a0, Lx0]; % initial guesses
        errfn = @(x) sum((km.spec.Coh-exp(-x(1).*sqrt(((km.spec.f.*deltax./U).^2) + ((0.12.*deltax./x(2)).^2)))).^2); % lst. sq. err. optimize
% errfn = @(a) trapz(1./km.Sij(:,fi,fj)).*sum(km.Sij(:,fi,fj).*(Cij(:,fi,fj) - exp(-a.*km.grd.std_u(fi,fj).*fuu.*deltax./(U.^2))).^2);
        opts = optimset('MaxFunEvals',nEval, 'MaxIter',nIter,... % options for fminsearch
                               'TolFun', Tol, 'TolX', Tol, 'Display', 'off');%,'fminunc', 'Algorithm', 'quasi-newton');
        [hat_x, ~, ~]  = fminsearch(errfn, x0, opts);
        hat_a = hat_x(1);
        hat_Lx = hat_x(2);
%         hat_xL = hat_Lx/2.7;
        if isolatedEstimation == 1
          opts = optimset('MaxFunEvals',nEval, 'MaxIter',nIter,...
                               'TolFun', Tol, 'TolX', Tol, 'Display', 'off');%,'fminunc', 'Algorithm', 'quasi-newton');
          errfun1 = @(a) sum((km.spec.Coh - exp(-a.*sqrt(((km.spec.f.*deltax./U).^2) + ((0.12.*deltax./340.1).^2)))).^2);
          [hat_a1,~,~] = fminsearch(errfun1, a0, opts);
          errfun2 = @(Lx) sum((km.spec.Coh - exp(-a0.*sqrt(((km.spec.f.*deltax./U).^2) + ((0.12.*deltax./Lx).^2)))).^2);
          [hat_Lx1,~,~] = fminsearch(errfun2, Lx0, opts);
        end

    end
    if PlotFig == 1
      figure; semilogx(km.fii, km.Sii, 'LineWidth', 1.5);
      xlabel('$$F_s$$ (Hz)','interpreter', 'latex', 'FontSize', 16);
      ylabel('$$S_{uu}$$ (dB)','interpreter', 'latex', 'FontSize', 16);
      ax = gca;
      ax.FontSize = 14;
    end

elseif strmatch(Analyse, 'plane')
    % Find the distance betweent the centre of rotor and subsequent points
    y = flip(y);                                                                        %  Bladed has inverted y axis
    [Y, Z] = meshgrid(y, z );                                                      %  repmat of the distances
    km.ref_pt = [0 0];                                                             % reference point i,e. hub centre
    km.spec.r = sqrt((km.ref_pt(1) - Y).^2 + (km.ref_pt(2)-Z).^2);                 % relative distances from the centre

    % Calculation of the cross spectra, spectra and coherence
    km.Sij = zeros(Nx/2+1, Ny, Nz);
    km.Sii = zeros(Nx/2+1, Ny, Nz);
    km.Sjj = zeros(Nx/2+1,Ny, Nz);
    CoCoh = zeros(Nx/2+1, Ny, Nz);
    QuadCoh = zeros(Nx/2+1, Ny, Nz);
    Coh = zeros(Nx/2+1, Ny, Nz);
    Phase = zeros(Nx/2+1, Ny, Nz);
    Cij = zeros(Nx/2+1, Ny, Nz);
    G = zeros(Nx/2+1, Ny, Nz);
    P = zeros(Nx/2+1, Ny, Nz);
    Q = zeros(Nx/2+1,Ny, Nz);
    xL = zeros(Ny, Nz);
    xT = xL;
    Iu = xL;
    hat_a = xL;
    hat_Lx = xL;
    hat_xL = xL;
    hat_L1 = xL;
    hat_a1 = xL;
    km.spec.var_u = xL;
    ls_L = xL;
    km.spec.Suu = zeros(Nx/2+1, Ny, Nz);

% Assign struct variables to temp variables
temp_dt = km.spec.dt;
temp_f = km.spec.f;
ref_u = km.ref_u;
win = km.spec.win;
noverlap = km.spec.noverlap;
Nfft = km.spec.Nfft;
Fs = km.spec.Fs;
Spectrum = km.spec.Spectrum;
T = km.spec.T;
r = km.spec.r;
    for fj = 1:Nz
        temp_u = reshape(ug(:,:,fj),[],Ny,1);
        temp_v = reshape(vg(:,:,fj),[],Ny,1);
        temp_w = reshape(wg(:,:,fj),[],Ny,1);
        uc = reshape(u(:,:,fj),[], Ny, 1);
        std_u = nan(Ny,1);
        std_v = nan(Ny,1);
        std_w = nan(Ny,1);
        var_u = nan(Ny,1);
        cov_u = nan(Ny,1);
        R_u = nan(Ny,1);
        Rij = nan(Ny,1);
        Tdelay = nan(Ny,1);
        uu = nan(Nx,1);
        Sii = zeros(Nfft/2+1,Ny);
        Sjj = zeros(Nfft/2+1,Ny);
        Sij = zeros(Nfft/2+1,Ny);
        Suu = zeros(Nfft,Ny);
        Cuu = zeros(Nfft,Ny);
        CoCoh = zeros(Nfft/2+1,Ny);
        QuadCoh = zeros(Nfft/2+1,Ny);
        Coh = zeros(Nfft/2+1,Ny);
        Cij = zeros(Nfft/2+1,Ny);
        rootCij = Cij;
        P = zeros(Nfft/2+1,Ny);
        Q = zeros(Nfft/2+1,Ny);
        G = zeros(Nfft/2+1,Ny);
        Phase = zeros(Nfft/2+1,Ny);
        xL = nan(Ny,1);
        xT = nan(Ny,1);
        Iu = nan(Ny,1);
        hat_a = nan(Ny,1);
        hat_Lx = nan(Ny,1);
        hat_a1 = nan(Ny,1);
        hat_L1 = nan(Ny,1);
        fmin_L = nan(Ny,1);
        ls_L = nan(Ny,1);
        ls_a = nan(Ny,1);
        ls_Lc = nan(Ny,1);
        for fi =  1:Ny
            % General statistics
            std_u(fi) = nanstd(temp_u(:,fi));                                 % standard deviaion
            std_v(fi) = nanstd(temp_v(:,fi));                                 % standard deviaion
            std_w(fi) = nanstd(temp_w(:,fi));                                 % standard deviaion
            var_u(fi) = var(temp_u(:,fi));                                    % variance
            std_uc(fi) = nanstd(uc(:,fi));                                    % std dev in the unscaled u component
            var_uc(fi) = var(uc(:,fi));                                       % variance in the unscaled u component
            cov_u(fi) = cov(temp_u(:,fi));                                    % covariance
            [R_mat, ~] = corrcoef(temp_u(:,fi), ug(:,floor(Nz/2)+1,floor(Nz/2)+1));                             % cross-correlation coefficient
            R_u(fi) = R_mat(2).*R_mat(3);
            [xC, xlags] = xcorr(temp_u(:,fi), ug(:,floor(Nz/2)+1,floor(Nz/2)+1), 'coeff');
            [Rij(fi),imax] = max(xC);
            Tdelay(fi) = xlags(imax)*temp_dt;
            uu = temp_u(:,fi);                                                       % temporary allocation of u-comp time series
            uuc= uc(:,fi);
            temp_r = r(fj,fi);

            % Calculate the spectrum using the IEC formulation
            lambda1 = 42; % turbulence scale parameter (for H >= 60m)
            Lk1 = 8.1*lambda1; % isotropic integral scale parameter 8.1*L1 - u,2.7*L1 - v, 0.66*L1 - w component
            Suu(1:km.spec.N,fi) = (std_u(fi).^2).*(4.*Lk1./U)./((1+6.*temp_f.*Lk1./U).^(5/3)); % autopower PSD
            Suuc(1:km.spec.N,fi) = (std_uc(fi).^2).*(4.*Lk1./U)./((1+6.*temp_f.*Lk1./U).^(5/3)); % autopower PSD of unscaled u component
            Cuu(1:km.spec.N,fi) = exp(-12.*sqrt(((temp_f.*r(fj,fi)./U).^2) + ((0.12.*r(fj,fi)./Lk1).^2))); % coherence IEC

            % Calculate the spectra using cpsd
             win_C = 2^10;
             noverlap_C = win_C*1/2;
            if ~isempty(strmatch('cpsd',funSpec))
                [Sii_temp, fii] = cpsd(ref_u, ref_u, hamming(win_C), noverlap_C, Nfft, Fs, Spectrum);
                [Sjj_temp, fjj] = cpsd(uu, uu, hamming(win_C), noverlap_C, Nfft, Fs, Spectrum);
                [Sjjc_temp, fjjc] = cpsd(uuc, uuc, hamming(win_C), noverlap_C, Nfft, Fs, Spectrum); % unscaled u component
                [Sij_temp, fij] = cpsd(ref_u, uu, hamming(win_C), noverlap_C, Nfft, Fs, Spectrum);
            % Calculate the spectra using specest
            elseif ~isempty(strmatch('specest',funSpec))
                [Sii_temp, fii] = specest(ref_u+U, Nfft, Fs, noverlap); %
                [Sjj_temp, fjj] = specest(uu+U, Nfft, Fs, noverlap);
                [Sij_temp]     = (crosspec(fii, U, r(fj,fi), 100, 0.1))';
                fij =  fii';
            % Compute the signal spectrum using pwelch
            elseif ~isempty(strmatch('pwelch',funSpec))
                 [Sii_temp, fii] = pwelch(ref_u, win, noverlap, Nfft, Fs, Spectrum); %
                 [Sjj_temp, fjj] = pwelch(uu, win, noverlap, Nfft, Fs, Spectrum);
                 [Cij_msc, fij_msc] = mscohere(ref_u, uu, win_C, noverlap_C, Nfft, Fs, Spectrum);
                 Sij_temp = sqrt(Cij_msc.*Sii_temp.*Sjj_temp);
                 Theta_ij = angle(Sij_temp);         % in radians
                 fij = fij_msc;
            end

            % Normalizing the spectrum, local
            if NormalizeSpectrum == 1
              Sii_temp = Sii_temp/KMU;
              Sjj_temp = Sjj_temp/KMU;
              Sij_temp = Sij_temp/KMU;
            end % normalize

            % Transfer the power in the spectrum to one side
            if ~isempty(strmatch('twosided', Spectrum)) || ~isempty(strmatch('centered', Spectrum))
                Sii_temp(1:Nfft/2-1) = [];
                Sjj_temp(1:Nfft/2-1) = [];
                Sij_temp(1:Nfft/2-1) = [];
                Sjjc_temp(1:Nfft/2-1) = [];
                Sii_temp(2:end) = 2.*Sii_temp(2:end);
                Sjj_temp(2:end) = 2.*Sjj_temp(2:end);
                Sij_temp(2:end) = 2.*Sij_temp(2:end);
                Sjjc_temp(2:end) = 2.*Sjjc_temp(2:end);
                Sii(:,fi) = Sii_temp;
                Sjj(:,fi) = Sjj_temp;
                Sij(:,fi) = Sij_temp;
                Sjjc(:,fi) = Sjjc_temp;
                f = (0:(Nfft/2))'/(Nfft/2).*Fs/2;
                fuu = f;
            else
                Sii(:,fi) = Sii_temp;
                Sjj(:,fi) = Sjj_temp;
                Sij(:,fi) = Sij_temp;
                Sjjc(:,fi) = Sjjc_temp;
                f = (0:(Nfft/2))'/(Nfft/2).*Fs/2;
            end % spectrum

             % Calculate the coÂ´coherence and quad coherence
            CoCoh(:,fi) = real(Sij_temp)./(sqrt(Sii_temp.*Sjj_temp)); % root co-coherence
            QuadCoh(:,fi) = imag(Sij_temp)./(sqrt(Sii_temp.*Sjj_temp)); % root quad-coherence
            Coh(:,fi) = CoCoh(:,fi).^2+QuadCoh(:,fi).^2;             % mag. squared Coherence
            Phase(:,fi) = atan(imag(Sij_temp)./real(Sij_temp));    % phase shift
            Cij(:,fi) = ((abs(Sij_temp)).^2)./(Sii_temp.*Sjj_temp);         % coherence acc. to Burton2011, IEC2010, Veers, ESDU.
            G(:,fi) = sqrt(Sii_temp./Sjj_temp);              % complex transfer function
            P(:,fi) = Cij(:,fi).*cosd(Phase(:,fi)).*sqrt(Sii_temp.*Sjj_temp);
            Q(:,fi) = Cij(:,fi).*sind(Phase(:,fi)).*sqrt(Sii_temp.*Sjj_temp);
            rootCij(:,fi) = sqrt((P(:,fi).^2 + Q(:,fi).^2)./(Sii_temp.*Sjj_temp)); % magniutude squared coherence
            rootCij(:,fi) = sqrt(Cij(:,fi));
%             Cij(:,fi) = smooth(Cij(:,fi),0.1,'moving');

            if (verifyScales == 1)
                % Turbulent length scale from the simulation
                [xL(fi), xT(fi), ~ ] = FnTurbLengthScale(uu, temp_dt, U, 'excludeDecay');
                % Compute the turbulence intensity in percent
                Iu(fi) = (std_u(fi)./U)*100;
                % Fitting the decay coefficient to the measurements
                deltax = r(fj,fi);
                a0 = 12;
                Lx0 = 340.1;
                x0 = [a0, Lx0];
                Thres_idx = find(round(f,3)==Threshold_f);
                errfn = @(x) sum((rootCij(:,fi) - exp(-x(1).*deltax.*sqrt(((f./U).^2) + ((0.12/x(2)).^2)))).^2);
                opts = optimset('MaxFunEvals',nEval, 'MaxIter',nIter,...
                                       'TolFun', Tol, 'TolX', Tol, 'Display', 'off');%,'fminunc', 'Algorithm', 'quasi-newton');
                [hat_x, ~, ~]  = fminsearch(errfn, x0, opts);
                hat_a(fi) = hat_x(1);
                hat_Lx(fi) = hat_x(2);
%                temp_hat_xL(fi) = temp_hat_Lx(fi)/2.7;

                if isolatedEstimation == 1
                   a0 = 12;
                   Lx0 = 340.1;
                  opts = optimset('MaxFunEvals',nEval, 'MaxIter',nIter,...
                                       'TolFun', Tol, 'TolX', Tol, 'Display', 'off');                                   % options for fminsearch
                  errfun1 = @(a) sum((rootCij(1:Thres_idx,fi) - exp(-a.*deltax.*sqrt(((f(1:Thres_idx)./U).^2) + ((0.12./Lk1).^2)))).^2); % optimisation fn for decay factor
                  [hat_a1(fi),~,~] = fminsearch(errfun1, a0, opts);                                                      % searching the minimum of the objective error function
                  errfun2 = @(Lx) sum((rootCij(1:Thres_idx,fi) - exp(-a0.*deltax.*sqrt(((f(1:Thres_idx)./U).^2) + ((0.12./Lx).^2)))).^2); % optimisation fn for length scale, very slow
                  [hat_L1(fi),~,~] = fminsearch(errfun2, Lx0, opts);                                                     % searching the minimum of the objective error function

                  % Least squares method for length scale and decay factor using coherence
                  SpecFn = @(Lc,f) (exp(-12.*deltax.*sqrt(((f./U).^2) + ((0.12./Lc).^2))));
                  Lc0 = 340.1;
                  opts= optimset('Display','off', 'MaxFunEvals', nEval, 'MaxIter', nIter, 'TolFun', Tol, 'TolX', Tol);
                  ls_Lc(fi) = lsqcurvefit(SpecFn, Lc0, fuu(1:Thres_idx), rootCij(1:Thres_idx,fi), 0, 600);
                  SpecFn = @(a,f) (exp(-a.*deltax.*sqrt(((f./U).^2) + ((0.12./Lx0).^2))));
                  a0 = 12;
                  ls_a(fi) = lsqcurvefit(SpecFn, a0, fuu(1:Thres_idx), rootCij(1:Thres_idx,fi), 0, 50);
                end

                % Length scale from fminsearch, works and spectrum comparison
                var_uc(fi) = sum(Sjjc_temp)./T;
                SpecFn = @(L) sum(((Sjjc_temp) - (var_uc(fi).*(4.*L./U)./((1+6.*fuu.*L./U).^(5/3)))).^2);
                opts = optimset('MaxFunEvals',nEval, 'MaxIter',nIter,'TolFun', Tol, 'TolX', Tol, 'Display', 'off');
                L0 = 340;
                [hat_L,~,~] =fminsearch(SpecFn, L0, opts);
                fmin_L(fi)= hat_L;

                % Length scale from least square fits and spectrum comparison
                Specfn = @(L,ff) (var_u(fi).*(4.*L./U)./((1+6.*ff.*L./U).^(5/3)));
                L0 = 340;
                opts= optimset('Display','off', 'MaxFunEvals', nEval, 'MaxIter', nIter, 'TolFun', Tol, 'TolX', Tol);
                ls_L(fi) = lsqcurvefit(Specfn, L0, temp_f, Suu(1:Nx,fi), 0, 600);
            end
%            fprintf('[%s] Grid points processed z: %d/%d \n', datetime('now'), fi,Nz)
        end % fi
%        km = struct;
        final_std_u(fj,:) = std_u;
        final_std_v(fj,:) = std_v;
        final_std_w(fj,:) = std_w;
        final_var_u(fj,:) = var_u;
        final_cov_u(fj,:) = cov_u;
        final_var_uc(fj,:) = var_uc;
        final_std_uc(fj,:) = std_uc;
        final_R_u(fj,:) = R_u;
        final_Rij(fj,:) = Rij;
        final_Tdelay(fj,:) = Tdelay;
        final_xL(fj,:) = xL;
        final_xT(fj,:) = xT;
        final_Iu(fj,:) = Iu;
        final_hat_a(fj,:) = hat_a;
        final_hat_Lx(fj,:) = hat_Lx;
        final_hat_a1(fj,:) = hat_a1;
        final_hat_L1(fj,:) = hat_L1;
        final_fmin_L(fj,:) = fmin_L;
        final_ls_L(fj,:) = ls_L;
        final_ls_Lc(fj,:) = ls_Lc;
        final_ls_a(fj,:) = ls_a;
        final_Sii(:,fj,:) = reshape(Sii,[],1,Nz);
        final_Sjj(:,fj,:) = reshape(Sjj,[],1,Nz);
        final_Sij(:,fj,:) = reshape(Sij,[],1,Nz);
        final_Suu(:,fj,:) = reshape(Suu, [], 1, Nz);
        final_Suuc(:,fj,:) = reshape(Suuc,[],1,Nz);
        final_Cuu(:,fj,:) = reshape(Cuu, [], 1, Nz);
        final_CoCoh(:,fj,:) = reshape(CoCoh, [],1,Nz);
        final_QuadCoh(:,fj,:) = reshape(QuadCoh, [],1,Nz);
        final_Coh(:,fj,:) = reshape(Coh, [],1,Nz);
        final_Phase(:,fj,:) = reshape(Phase, [],1,Nz);
        final_Cij(:,fj,:) = reshape(Cij, [],1,Nz);
        final_rootCij(:,fj,:) = reshape(rootCij, [],1,Nz);
        final_G(:,fj,:) = reshape(G, [],1,Nz);
        final_P(:,fj,:) = reshape(P, [],1,Nz);
        final_Q(:,fj,:) = reshape(Q, [],1,Nz);
         fprintf('[%s] Grid points processed y: %d/%d \n', datetime('now'), fj,Ny)
    end % fj
else
    error('Please check the input, domain is not yet defined or error in input');
end % point/ plane or domain

% Post filtering criteria

%% Plotting all the results
if PlotFig == 1
  figure(); semilogx(fuu, fuu.*abs(km.Sii(:,floor(Ny/2)+1,floor(Ny/2)+1))./max(abs(km.Sii(:,floor(Ny/2)+1,floor(Ny/2)+1)))); title('Sii');
  figure(); semilogx(fuu, km.fuu.*abs(km.Sjj(:,floor(Ny/2)+1,floor(Ny/2)+1))./max(abs(km.Sjj(:,floor(Ny/2)+1,floor(Ny/2)+1)))); title('Sjj');
  figure(); semilogx(fuu, fuu.*abs(km.Sij(:,floor(Ny/2)+1,floor(Ny/2)+1))./max(abs(km.Sij(:,floor(Ny/2)+1,floor(Ny/2)+1)))); title('Sij');
end %fig

if PlotFig == 1
    figure; semilogx(fuu, fuu.*Cij(:,floor(Ny/2)+1,floor(Ny/2)+1)); title('Cij');
    figure; semilogx(fuu, fuu.*P(:,floor(Ny/2)+1,floor(Ny/2)+1)); title('P');
    figure; semilogx(fuu, fuu.*Q(:,floor(Ny/2)+1,floor(Ny/2)+1)); title('Q');
end

if PlotFig == 1
    % Variation of coherence decay across the rotor disc
    xx = final_ls_a;
%     idx = (xx < 0) | (xx > 800);
%     xx(idx) = 340.1;
%     fprintf('[%s] Number of outliers replaced:%d \n',datetime('now'), sum(idx(:)));
    h1 = figure();
    colormap(flipud(gray));
    [c1,hc1]= contourf(interp2(Y,5,'linear'),interp2(Z,5, 'linear'),interp2(xx,5, 'linear'));
    set(hc1,'LineColor', [0.7 0.7 0.7], 'LineWidth', 0.5);
    set(h1, 'Renderer', 'opengl');
%    title('Variation of coherence decay parameter (a) over the rotor disc');
    xlabel('y-axis in rotor plane (m)');
    ylabel('z-axis in rotor plane (m)')
    colormap(h1, flipud(gray));
    colorbar;
    saveas(h1, 'Kaimal_Turbsim_individualScaling_ls_a.eps');


    % Variation of length scale across the rotor disc
    h2 = figure();
    colormap(flipud(gray));
    [c2,hc2]= contourf(interp2(Y,5,'linear'),interp2(Z,5, 'linear'),interp2(final_ls_Lc,5,'linear'));
    set(hc2,'LineColor', [0.7 0.7 0.7], 'LineWidth', 0.5);
    set(h2, 'Renderer', 'opengl');
    colormap(h2, flipud(gray));
    xlabel('y-axis in rotor plane');
    ylabel('z-axis in rotor plane');
    colorbar;
    saveas(h2, 'Kaimal_Turbsim_individualScaling_ls_Lc.eps');

    % Variation of turbulence intensity across the rotor disc
    h3 = figure();
    colormap(flipud(gray));
    [c3,hc3]= contourf(interp2(Y,5,'linear'),interp2(Z,5, 'linear'),interp2(final_Iu,5,'linear'));
    set(hc3,'LineColor', [0.7 0.7 0.7], 'LineWidth', 0.5);
    set(h3, 'Renderer', 'opengl');
    colormap(h3, flipud(gray));
    xlabel('y-axis in rotor plane');
    ylabel('z-axis in rotor plane');
    colorbar;
    saveas(h3, 'Kaimal_Turbsim_individualScaling_Iu.eps');

    % Variation of length scale from spectrum across the rotor disc
    h4 = figure();
    colormap(flipud(gray));
    [c4,hc4]= contourf(interp2(Y,5,'linear'),interp2(Z,5, 'linear'),interp2(final_ls_L,5,'linear'));
    set(hc4,'LineColor', [0.7 0.7 0.7], 'LineWidth', 0.5);
    set(h4, 'Renderer', 'opengl');
    colormap(h4, flipud(gray));
    xlabel('y-axis in rotor plane');
    ylabel('z-axis in rotor plane');
    colorbar;
    saveas(h4, 'Kaimal_Turbsim_individualScaling_ls_L.eps');


    % Variation of length scale from spectrum across the rotor disc
    xx = final_xL;
    idx = (xx < 0) | (xx > 300);
    xx(idx) = nanmean(xx(~idx));
    fprintf('[%s] Number of outliers replaced:%d \n',datetime('now'), sum(idx(:)));
    h5 = figure();
    colormap(flipud(gray));
    [c5,hc5]= contourf(interp2(Y,5,'linear'),interp2(Z,5, 'linear'),interp2(xx,5,'linear'));
    set(hc5,'LineColor', [0.7 0.7 0.7], 'LineWidth', 0.5);
    set(h5, 'Renderer', 'opengl');
    colormap(h5, flipud(gray));
    xlabel('y-axis in rotor plane');
    ylabel('z-axis in rotor plane');
    colorbar;
    saveas(h5, 'Kaimal_Turbsim_individualScaling_xL.eps');

end

if PlotFig == 1
  figure(); semilogx(fuu, fuu.*abs(km.Sii(:,floor(Ny/2)+1,floor(Ny/2)+1))./max(abs(km.Sii(:,floor(Ny/2)+1,floor(Ny/2)+1)))); title('Sii');
  figure(); semilogx(fuu, fuu.*abs(km.Sjj(:,floor(Ny/2)+1,floor(Ny/2)+1))./max(abs(km.Sjj(:,floor(Ny/2)+1,floor(Ny/2)+1)))); title('Sjj');
  figure(); semilogx(fuu, fuu.*abs(km.Sij(:,floor(Ny/2)+1,floor(Ny/2)+1))./max(abs(km.Sij(:,floor(Ny/2)+1,floor(Ny/2)+1)))); title('Sij');
end %fig

if (Validation == 1) & (Analyse=='plane')
  L = reshape(final_ls_L,[],Ny*Nz);
  var_u = reshape(final_var_u,[], Ny*Nz);
  Sii_valid = var_u.*(4.*L./U)./((1+6.*fuu.*L./U).^(5/3));
  figure;
  semilogx(fuu,Sii_valid,'-', 'Color', [0.7 0.7 0.7]);
  legend('Estimated');
  hold on;
  s2 = semilogx(fuu, final_Suu(1:km.spec.Nfft/2+1,floor(Ny/2)+1,floor(Nz/2)+1), 'k-', 'LineWidth', 2, 'DisplayName', 'IEC');
  hold off;
  ylabel('Spectrum power (dB)', 'FontSize', 14);
  xlabel('Frequency (Hz)', 'FontSize', 14);

  figure;
  C = reshape(final_Phase, [], Ny*Nz);
  semilogx(fuu,C,'-','Color',[0.7 0.7 0.7]);
  title('QuadCoh')
end
disp('Calculation performed for cpsd with win=2^10 length  and moving averaging the coherence curve beforehand for smoother coherence plots')
toc

if (Analyse=='plane')
  % Contour plot for for coherence plots in the lateral direction
  gx = [1, 4, 8, 10, 14, 17];
  for ig = 1:numel(gx)
  figure(30+ig);
  semilogx(fuu(1:Thres_idx), (final_CoCoh(1:Thres_idx, gx(ig), floor(Nz/2)+1)), ':', 'Color', [0.7 0.7 0.7], 'LineWidth', 1.5); hold on;% plots co-coherence i.e. real part of coherence
  semilogx(fuu(1:Thres_idx),final_Cuu(1:Thres_idx,gx(ig), floor(Nz/2)+1),'k-','LineWidth', 1.5);hold on; % plots IEC based coherence (not sure if mag. squared Coherence or root coherence)
  semilogx(fuu(1:Thres_idx), (final_Coh(1:Thres_idx, gx(ig), floor(Nz/2)+1)), 'b-.', 'LineWidth', 1.5);hold on; % plots magnitude squared coehrence
  semilogx(fuu(1:Thres_idx), (final_QuadCoh(1:Thres_idx,gx(ig), floor(Nz/2)+1)), 'g-.', 'LineWidth', 1.5); hold on; % plots quad-coherence i.e. imaginary part of coherence
  semilogx(fuu(1:Thres_idx), (final_rootCij(1:Thres_idx, gx(ig), floor(Nz/2)+1)), 'm--', 'LineWidth', 1.5); hold on;% plots root-coherence as mentioned in Burton, ESDU, Veers
  semilogx(fuu(1:Thres_idx), abs(final_Sii(1:Thres_idx, gx(ig), floor(Nz/2)+1))./max(abs(final_Sii(:, gx(ig), floor(Nz/2)+1))), 'ro-', 'LineWidth', 1); hold on;
  semilogx(fuu(1:Thres_idx), abs(final_Sjj(1:Thres_idx, gx(ig), floor(Nz/2)+1))./max(abs(final_Sjj(:, gx(ig), floor(Nz/2)+1))), 'rx-', 'LineWidth', 1); hold on;
  semilogx(fuu(1:Thres_idx), abs(final_Sij(1:Thres_idx, gx(ig), floor(Nz/2)+1))./max(abs(final_Sij(:, gx(ig), floor(Nz/2)+1))), 'rd-', 'LineWidth', 1); hold off;
  legtext1 = ['CoCoh r = ' num2str(y(gx(ig)))];
  legtext2 = ['IEC r = ' num2str(y(gx(ig)))];
  legtext3 = ['Coh r = ' num2str(y(gx(ig)))];
  legtext4 = ['QuadCoh r = ' num2str(y(gx(ig)))];
  legtext5 = ['rootCoh r = ' num2str(y(gx(ig)))];
  legtext6 = ['Sii r = ' num2str(y(gx(ig)))];
  legtext7 = ['Sjj r = ' num2str(y(gx(ig)))];
  legtext8 = ['Sij r = ' num2str(y(gx(ig)))];
  leg = legend(legtext1, legtext2, legtext3, legtext4, legtext5, legtext6,legtext7, legtext8);
  set(leg, 'color', 'none', 'Location', 'southwest')
  xlabel('Frequency (Hz)');
  ylabel('Coherence (-)');
%   tikzName = sprintf('Kaimal_CompareCoh_Turbsim_individualScaling_y%.0f.tex',y(gx(ig)))
%   matlab2tikz(tikzName)
  end
  % Coherence plots along the vertical direction
  for ig = 1:numel(gx)
  figure(ig);
  semilogx(fuu(1:Thres_idx), final_CoCoh(1:Thres_idx, floor(Ny/2)+1, gx(ig)), ':', 'Color', [0.7 0.7 0.7], 'LineWidth', 1.5); hold on;% plots co-coherence i.e. real part of coherence
  semilogx(fuu(1:Thres_idx),final_Cuu(1:Thres_idx,floor(Ny/2)+1, gx(ig)),'k-','LineWidth', 1.5);hold on;% plots IEC based coherence (not sure if mag. squared Coherence or root coherence)
  semilogx(fuu(1:Thres_idx), final_Coh(1:Thres_idx, floor(Ny/2)+1, gx(ig)), 'b-.', 'LineWidth', 1.5);hold on; % plots magnitude squared coehrence
  semilogx(fuu(1:Thres_idx), final_QuadCoh(1:Thres_idx,floor(Ny/2)+1, gx(ig)), 'g-.', 'LineWidth', 1.5);hold on; % plots quad-coherence i.e. imaginary part of coherence
  semilogx(fuu(1:Thres_idx), final_rootCij(1:Thres_idx, floor(Ny/2)+1, gx(ig)), 'm--', 'LineWidth', 1.5);hold on; % plots root-coherence as mentioned in Burton, ESDU, Veers
  semilogx(fuu(1:Thres_idx), abs(final_Sii(1:Thres_idx, floor(Ny/2)+1, gx(ig)))./max(abs(final_Sii(:, floor(Ny/2)+1, gx(ig)))), 'ro-', 'LineWidth', 1); hold on;
  semilogx(fuu(1:Thres_idx), abs(final_Sjj(1:Thres_idx, floor(Ny/2)+1, gx(ig)))./max(abs(final_Sjj(:, floor(Ny/2)+1, gx(ig)))), 'rx-', 'LineWidth', 1); hold on;
  semilogx(fuu(1:Thres_idx), abs(final_Sij(1:Thres_idx, floor(Ny/2)+1, gx(ig)))./max(abs(final_Sij(:, floor(Ny/2)+1, gx(ig)))), 'rd-', 'LineWidth', 1); hold off;
  legtext1 = ['CoCoh r = ' num2str(z(gx(ig)))];
  legtext2 = ['IEC r = ' num2str(z(gx(ig)))];
  legtext3 = ['Coh r = ' num2str(z(gx(ig)))];
  legtext4 = ['QuadCoh r = ' num2str(z(gx(ig)))];
  legtext5 = ['rootCoh r = ' num2str(z(gx(ig)))];
  legtext6 = ['Sii r = ' num2str(z(gx(ig)))];
  legtext7 = ['Sjj r = ' num2str(z(gx(ig)))];
  legtext8 = ['Sij r = ' num2str(z(gx(ig)))];
  leg = legend(legtext1, legtext2, legtext3, legtext4, legtext5, legtext6,legtext7, legtext8);
  set(leg, 'color', 'none', 'Location', 'southwest')
  xlabel('Frequency (Hz)');
  ylabel('Coherence (-)');
%   tikzName = sprintf('Kaimal_CompareCoh_Turbsim_individualScaling_z%.0f.tex',z(gx(ig)))
%   matlab2tikz(tikzName)
  end

  if PlotFig == 1
  semilogx(fuu(1:Thres_idx), final_Cuu(1:Thres_idx,6,6),'k-', 'LineWidth', 1.5); hold on;
  semilogx(fuu(1:Thres_idx), final_Coh(1:Thres_idx,6,6),'b-', 'LineWidth', 1.5); hold on;
  semilogx(fuu(1:Thres_idx), final_Cij(1:Thres_idx,6,6),'r--', 'LineWidth', 1.5); hold on;
  semilogx(fuu(1:Thres_idx), final_rootCij(1:Thres_idx,6,6),'g--', 'LineWidth', 1.5); hold on;
  end
end


